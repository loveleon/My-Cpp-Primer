13.1 拷贝构造函数是第一个参数是自身引用类型，其他参数存在且有默认值的构造函数。
1）初始化函数非引用类型的形参；2)返回一个非引用类型返回值；3)(用花括号)初始化数组元素类型或聚合类成员；
13.2 导致无限次拷贝构造调用。为了调用拷贝构造函数，必须拷贝它的实参;为了构造实参,需要调用拷贝构造;
13.3 StrBlob 会使shared_ptr引用加1.StrBlobPtr成员是weak_ptr不会导致引用加1.
13.4 函数形参调用；local变量; new Point(global) ;花括号初始化列表形式，pa[4]数组元素构造 ;return返回拷贝构造
13.6 通过重载赋值运算符，接受一个类对象，赋值另一个类对象。如果未定义拷贝运算符，类会合成拷贝运算符。拷贝运算符将类非static成员依次赋值给目的对象。
13.7 将StrBlob对象赋值给另一个，shared_ptr引用会加1.而将StrBlobPtr赋值，并不会使shared_ptr引用计数加1.
13.9 析构函数在对象生命期结束时,自动调用,销毁对象的不能重载的成员函数.合成析构函数被用来阻止对象销毁.当未定义析构函数时候,编译器合成析构函数.
13.10 当StrBlob对象销毁,成员shared_ptr会减少一次引用计数,如果引用计数为0,则释放shared_ptr指针。StrBlobPtr直接释放成员指针。
13.12 析构函数调用三次，accum，item1，item2.当指向对象的指针或引用，离开作用域时候，析构函数不会被调用。
13.14 fa fb fc输出相同结果。因为使用合成拷贝控制成员，直接进行普通拷贝成员动作。
13.15 会改变。b c变量均调用拷贝构造函数，控制成员变量行为。
13.16 不会改变新输出结果。
13.19 需要定义自己拷贝构造函数。因为资源（序号）需要唯一，不同。默认拷贝构造，只进行值拷贝。
13.20 TextQuery生成QueryResult对象，当拷贝TextQuery 和 QueryResult时候，shared_ptr资源计数会加1.销毁对象，引用计数减1，当为0，释放对象资源。
13.21 TextQuery QueryResult是共享资源类型，使用同一份资源，拷贝shared_ptr成员，只是增加引用计数，并未拷贝一份资源。所以，不需要自定义拷贝构造和赋值。
13.24 未定义析构函数，销毁指针时候，不会释放动态内存资源，造成内存泄漏。未定义拷贝构造函数，类会生成默认拷贝构造函数，直接拷贝指针地址，可能造成二次内存释放。
13.29 swap(HasPtr,HasPtr)函数调用std::swap版本。
13.32 传值或引用版本，因为减少内存申请，所以，提高性能。而指针版本不有内存申请，所以不会有新的性能提升。
